#ifndef __HX_POLARSSL_HAVEGE_HPP
#define __HX_POLARSSL_HAVEGE_HPP

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_KIND(k_havege_state);


#define alloc_havege_state(v)     alloc_abstract(k_havege_state, v)
#define malloc_havege_state()     ((havege_state*)alloc_private(sizeof(havege_state)))
#define val_havege_state(v)       ((havege_state*)val_data(v))
#define val_check_havege_state(v) val_check_kind(v, k_havege_state)
#define val_is_havege_state(v)    val_is_kind(v, k_havege_state)


/*
 * Frees the HAVEGE state and all resources allocated for it.
 *
 * See:
 *   https://polarssl.org/api/havege_8h.html
 *
 * Example:
 *   hx_havege_free(alloc_havege_state(hs));
 *
 * Parameters:
 *   value[k_havege_state] hs the HAVEGE state pointer
 *
 * Returns:
 *   value[null] nothing is returned
 */
value hx_havege_free(value hs);


/*
 * Initializes and returns a HAVEGE state.
 *
 * See:
 *   https://polarssl.org/api/havege_8h.html
 *
 * Example:
 *   value hs = hx_havege_init();
 *
 * Returns:
 *   value[k_havege_state] the initialized HAVEGE state
 */
value hx_havege_init(void);


/*
 * Returns an 'nbytes' long series of random bytes.
 *
 * See:
 *   https://polarssl.org/api/havege_8h.html
 *
 * Example:
 *   value rand = hx_havege_random(alloc_havege_state(hd), alloc_int(32));
 *
 * Parameters:
 *   value[k_havege_state] hs     the HAVEGE state to use
 *   value[Int]            nbytes the number of random bytes to generate
 *
 * Returns:
 *   value[haxe.io.Bytes] the generated bytes
 */
value hx_havege_random(value hs, value nbytes);


/*
 * Finalizes the HAVEGE state by freeing associated memory.
 *
 * Example:
 *   finalize_havege_state(alloc_havege_state(hs));
 *
 * Parameters:
 *   value[k_havege_state] hs the HAVEGE state to finalize
 */
void finalize_havege_state(value hs);

#ifdef __cplusplus
} // extern "C"
#endif

#endif /* __HX_POLARSSL_HAVEGE_HPP */
